import type { Context } from "@netlify/functions";
import { getLLM } from "./lib/ai/provider";
import { generateFileContent } from "./lib/ai/chains/file-generator";
import { createRepo, pushFiles, getRepoInfo, analyzeRepo, getIssues, getUserRepos } from "./lib/github";
import type { ScaffoldRequest, PlanFeature } from "../../src/lib/types";

function generateScaffoldFiles(
  stack: string,
  projectName: string,
  features: PlanFeature[]
): Array<{ path: string; content: string }> {
  const files: Array<{ path: string; content: string }> = [];
  const isNextjs = stack.toLowerCase().includes("next");
  const isReact = stack.toLowerCase().includes("react") || isNextjs;
  const isTypescript = stack.toLowerCase().includes("typescript") || stack.toLowerCase().includes("ts");
  const ext = isTypescript ? "tsx" : "jsx";
  const extPlain = isTypescript ? "ts" : "js";

  // package.json
  const deps: Record<string, string> = {};
  const devDeps: Record<string, string> = {};

  if (isNextjs) {
    deps["next"] = "latest";
    deps["react"] = "^19.0.0";
    deps["react-dom"] = "^19.0.0";
    devDeps["@types/node"] = "^20";
    devDeps["@types/react"] = "^19";
    devDeps["typescript"] = "^5";
  }

  if (stack.toLowerCase().includes("tailwind")) {
    devDeps["tailwindcss"] = "^4";
    devDeps["@tailwindcss/postcss"] = "^4";
  }

  files.push({
    path: "package.json",
    content: JSON.stringify(
      {
        name: projectName,
        version: "0.1.0",
        private: true,
        scripts: {
          dev: isNextjs ? "next dev" : "echo \"Add dev script\"",
          build: isNextjs ? "next build" : "echo \"Add build script\"",
          start: isNextjs ? "next start" : "echo \"Add start script\"",
          lint: "eslint .",
        },
        dependencies: deps,
        devDependencies: devDeps,
      },
      null,
      2
    ),
  });

  // tsconfig.json
  if (isTypescript) {
    files.push({
      path: "tsconfig.json",
      content: JSON.stringify(
        {
          compilerOptions: {
            target: "ES2017",
            lib: ["dom", "dom.iterable", "esnext"],
            allowJs: true,
            skipLibCheck: true,
            strict: true,
            noEmit: true,
            esModuleInterop: true,
            module: "esnext",
            moduleResolution: "bundler",
            resolveJsonModule: true,
            isolatedModules: true,
            jsx: "react-jsx",
            incremental: true,
            paths: { "@/*": ["./src/*"] },
          },
          include: ["**/*.ts", "**/*.tsx"],
          exclude: ["node_modules"],
        },
        null,
        2
      ),
    });
  }

  // Next.js config
  if (isNextjs) {
    files.push({
      path: `next.config.${extPlain}`,
      content: `import type { NextConfig } from "next";\n\nconst nextConfig: NextConfig = {};\n\nexport default nextConfig;\n`,
    });

    // postcss config for Tailwind
    if (stack.toLowerCase().includes("tailwind")) {
      files.push({
        path: "postcss.config.mjs",
        content: `const config = {\n  plugins: {\n    "@tailwindcss/postcss": {},\n  },\n};\n\nexport default config;\n`,
      });
    }

    // App layout
    files.push({
      path: `src/app/layout.${ext}`,
      content: `import type { Metadata } from "next";
import "./globals.css";

export const metadata: Metadata = {
  title: "${projectName}",
  description: "Generated by buffr",
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
`,
    });

    // App page
    files.push({
      path: `src/app/page.${ext}`,
      content: `export default function Home() {
  return (
    <main>
      <h1>${projectName}</h1>
      <p>Welcome to your new project.</p>
    </main>
  );
}
`,
    });

    // Globals CSS
    files.push({
      path: "src/app/globals.css",
      content: stack.toLowerCase().includes("tailwind")
        ? `@import "tailwindcss";\n`
        : `* { margin: 0; padding: 0; box-sizing: border-box; }\n`,
    });
  }

  // Feature placeholder directories
  for (const feature of features.filter((f) => f.checked && f.phase === 1)) {
    const slug = feature.name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/(^-|-$)/g, "");
    if (isNextjs || isReact) {
      files.push({
        path: `src/features/${slug}/index.${extPlain}`,
        content: `// TODO: Implement "${feature.name}"\n// ${feature.description}\n// Complexity: ${feature.complexity}\n\nexport {};\n`,
      });
    }
  }

  return files;
}

export default async function handler(req: Request, _context: Context) {
  // GET handlers: ?validate=, ?analyze=, ?issues=, ?repos
  if (req.method === "GET") {
    const url = new URL(req.url);
    const validate = url.searchParams.get("validate");
    const analyze = url.searchParams.get("analyze");
    const issues = url.searchParams.get("issues");
    const repos = url.searchParams.has("repos");

    if (!validate && !analyze && !issues && !repos) {
      return new Response(JSON.stringify({ error: "Method not allowed" }), {
        status: 405,
        headers: { "Content-Type": "application/json" },
      });
    }

    // ?repos — list all repos for the authenticated GitHub user
    if (repos) {
      try {
        const repoList = await getUserRepos();
        return new Response(JSON.stringify(repoList), {
          headers: { "Content-Type": "application/json" },
        });
      } catch (err) {
        const message = err instanceof Error ? err.message : "Failed to fetch repos";
        return new Response(JSON.stringify({ error: message }), {
          status: 500,
          headers: { "Content-Type": "application/json" },
        });
      }
    }

    // ?analyze=owner/repo — full repo analysis + issues
    if (analyze) {
      try {
        const ownerRepo = analyze.replace(/\.git$/, "");
        const [owner, repo] = ownerRepo.split("/");
        if (!owner || !repo) {
          return new Response(
            JSON.stringify({ error: "Invalid owner/repo format" }),
            { status: 400, headers: { "Content-Type": "application/json" } }
          );
        }

        const info = await getRepoInfo(ownerRepo);
        if (!info) {
          return new Response(
            JSON.stringify({ error: "Repository not found" }),
            { status: 404, headers: { "Content-Type": "application/json" } }
          );
        }

        const [analysis, issueList] = await Promise.all([
          analyzeRepo(owner, repo, info.defaultBranch),
          getIssues(owner, repo),
        ]);

        return new Response(
          JSON.stringify({ ...analysis, issues: issueList, issueCount: issueList.length }),
          { headers: { "Content-Type": "application/json" } }
        );
      } catch (err) {
        const message = err instanceof Error ? err.message : "Failed to analyze repository";
        return new Response(JSON.stringify({ error: message }), {
          status: 500,
          headers: { "Content-Type": "application/json" },
        });
      }
    }

    // ?issues=owner/repo — fetch open issues only
    if (issues) {
      try {
        const ownerRepo = issues.replace(/\.git$/, "");
        const [owner, repo] = ownerRepo.split("/");
        if (!owner || !repo) {
          return new Response(
            JSON.stringify({ error: "Invalid owner/repo format" }),
            { status: 400, headers: { "Content-Type": "application/json" } }
          );
        }
        const issueList = await getIssues(owner, repo);
        return new Response(JSON.stringify(issueList), {
          headers: { "Content-Type": "application/json" },
        });
      } catch (err) {
        const message = err instanceof Error ? err.message : "Failed to fetch issues";
        return new Response(JSON.stringify({ error: message }), {
          status: 500,
          headers: { "Content-Type": "application/json" },
        });
      }
    }

    // ?validate=owner/repo — quick repo existence check
    try {
      const ownerRepo = validate!.replace(/\.git$/, "");
      const info = await getRepoInfo(ownerRepo);
      if (!info) {
        return new Response(
          JSON.stringify({ error: "Repository not found or not accessible" }),
          { status: 404, headers: { "Content-Type": "application/json" } }
        );
      }
      return new Response(JSON.stringify(info), {
        headers: { "Content-Type": "application/json" },
      });
    } catch (err) {
      const message = err instanceof Error ? err.message : "Failed to validate repository";
      return new Response(JSON.stringify({ error: message }), {
        status: 500,
        headers: { "Content-Type": "application/json" },
      });
    }
  }

  if (req.method !== "POST") {
    return new Response(JSON.stringify({ error: "Method not allowed" }), {
      status: 405,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    const body = (await req.json()) as ScaffoldRequest;

    // 1. Generate scaffold files
    const scaffoldFiles = generateScaffoldFiles(
      body.stack,
      body.projectName,
      body.features
    );

    // 2. Generate content for selected project files via LLM
    const llm = getLLM(body.provider || "anthropic");
    const featureNames = body.features
      .filter((f) => f.checked)
      .map((f) => f.name);

    const fileGenPromises = body.selectedFiles.map(async (fileType) => {
      const content = await generateFileContent(llm, {
        fileType,
        projectName: body.projectName,
        description: body.description,
        stack: body.stack,
        features: featureNames,
        constraints: body.constraints,
        goals: body.goals,
      });
      return { path: fileType, content };
    });

    const generatedFiles = await Promise.all(fileGenPromises);

    // 3. Combine all files
    const allFiles = [...scaffoldFiles, ...generatedFiles];

    // 4. Create GitHub repo
    const { owner, repo, url } = await createRepo(
      body.repoName,
      body.repoDescription,
      body.repoVisibility === "private"
    );

    // 5. Push all files
    await pushFiles(owner, repo, allFiles, "Initial commit from buffr");

    return new Response(
      JSON.stringify({
        repoUrl: url,
        githubRepo: `${owner}/${repo}`,
        files: allFiles.map((f) => f.path),
      }),
      { headers: { "Content-Type": "application/json" } }
    );
  } catch (err: unknown) {
    console.error("scaffold function error:", err);

    let message = "Failed to scaffold project";
    let status = 500;

    if (err instanceof Error) {
      const msg = err.message;
      if (msg.includes("credit balance is too low") || msg.includes("insufficient")) {
        message = "Your LLM provider account has insufficient credits. Please top up or switch providers.";
        status = 402;
      } else if (msg.includes("authentication") || msg.includes("API key") || msg.includes("Incorrect API key")) {
        message = "Invalid API key for the selected provider. Check your .env file.";
        status = 401;
      } else if (msg.includes("GITHUB_TOKEN") || msg.includes("not configured")) {
        message = msg;
        status = 400;
      } else if (msg.includes("rate limit") || msg.includes("Rate limit")) {
        message = "Rate limited by the LLM provider. Wait a moment and try again.";
        status = 429;
      } else if (msg.includes("already exists") || msg.includes("name already exists")) {
        message = "Repository name already exists. Go back and choose a different name.";
        status = 422;
      } else {
        message = msg;
      }
    }

    return new Response(JSON.stringify({ error: message }), {
      status,
      headers: { "Content-Type": "application/json" },
    });
  }
}
